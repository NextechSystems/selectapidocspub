# Authorization #

Nextech's implementation of the FHIRÂ® standard is protected by the [OAuth 2.0 standard](https://oauth.net/2/) for authenticating requests.  All API requests are authenticated by passing a Bearer token in the Authorization Header. There are two authentication models we use. We have a Partner Authentication and User Authentication.

```Authorization: Bearer {access_token}```
## Partner Authentication ##

### Request Access Token ###
Access tokens are used to make API requests on behalf of a user. These tokens are short-lived (1 hour by default) but should be kept confidential in transit and in storage. A `access_token` and `refresh_token` pair is issued when requesting an access token.

**HTTP Request**  
`POST https://login.microsoftonline.com/nextech-api.com/oauth2/token`

| Parameter | Description |
| --------- | ----------- |
| grant_type | Use `password` (Resource owner credentials grant) |
| client_id | Application ID |
| username | Resource owner username |
### Refresh Access Token ###
Refresh tokens are used to renew an expired access token without providing user credentials. A `access_token` and `refresh_token` pair is issued when requesting an access token using the resource owner credentials grant. A new pair is also generated when using the `refresh_token` grant type. 

**HTTP Request**  
`POST https://login.microsoftonline.com/nextech-api.com/oauth2/token`

| Parameter | Description |
| --------- | ----------- |
| grant_type | Always `refresh_token` |
| client_id | Application ID |
| refresh_token | A valid refresh token |

**Response Parameters**

| Parameter | Description |
| --------- | ----------- |
| token_type | Always `Bearer` |
| scope | Always `user_impersonation` |
| expires_in | The lifetime of the access token, in seconds. Default 3600 |
| access_token | The bearer token used in the `Authorization` header for subsquent requests |
| refresh_token | A long-lived token (14 days) used to renew expired access tokens without providing user credentials |


### Authorization With Postman ###

Postman makes it easy to acquire OAuth 2.0 access tokens. Use the information listed below for obtaining a token via the `authorization_code` grant type. When requesting a new token, you will be redirected to the _Auth URL_ listed below where you can enter your user credentials to authenticate. 

| Field | Value |
| ----- | ----- |
| Auth URL | `https://login.microsoftonline.com/nextech-api.com/oauth2/authorize?resource=https%3A%2F%2Fselect.nextech-api.com%2Fapi` |
| Access Token URL | `https://login.microsoftonline.com/nextech-api.com/oauth2/token` |
| Callback URL | `https://www.getpostman.com/oauth2/callback` |
| Client ID | Your application ID |
| Grant Type | `Authorization Code` |
| Client Authentication | `Send client credentials in body` |

## User Authentication ##
User Authentication allows application to access an individual user's information. This authentication flow uses the MyPatientVisit portal to grant access to specific users and specify the level of access via scopes. These applications will need to be registered with Nextech.
**Note: TLS 1.2 and PKCE S256 are both required when using User Authentication**

### Required Parameters ###
| Parameter | Description |
| --------- | ----------- |
| grant_type | Always `authorization_code` |
| client_id | Client ID given by Nextech |
| client_secret | A secret provided by Nextech |
| Scopes | A space delimited list of resources the application requires access to|
| Audience | A URI indicating where the token intends to be used |
| redirect_uri | A URI indicating where the user should be redirected to after they've granted access |
| response_type | Always `code` |
| code_challenge | This is a code generated by the client used to verify the client before authorization and including this indicates PKCE is being used |
| code_challenge_method | Always `S256` this indicates the code challenge will use SHA-256 for hashing |


### Example of Authorization With Postman ###
 Postman's authentication makes generating your first token a breeze. 
1. For a given postman collection go to the Authorization tab
1. Set Authorization to Oauth 2.0. This should give you additional fields to fill out
1. Header Prefix should be set to "Bearer"
1. Grant type ahould be set to Authorization code with PKCE using SHA256
1. Auth URL should be set to https://mypatientvisit-sts-dev.azurewebsites.net/connect/authorize
1. Access Token URL should be set to https://mypatientvisit-sts-dev.azurewebsites.net/connect/token
1. Client ID should be set to the value given to you by Nextech
1. Secret should be set to the value given to you by Nextech. NOTE: This *MUST* be stored securely and access to it highly limited
1. Code Challenge Method should be SHA-256
1. Scopes should contain all needed scopes. At a minimum this should be "launch/patient openid fhirUser"
1. Audience can be found under the *Advanced Options* tab and should be set to https://nxpartnerapi-dev.azurewebsites.net/api/r4

Once these fields are filled out and the authentication request is made your browser should open up to a login screen. The user will then login via their MyPatientVisit credentals. They will Select which practice and patient they are granting access to, and then they will verify the scopes. Once this is done you will have a callback to Postman (check browser popup settings and possibly try changing your default browser if that fails). When Postman receives this callback it will populate the access token. 

### Using the Authentication Token ###
To use the authentication token you will need to add an Authorization header, then set the value to "Bearer <token>" where <token> represents your token. No other headers are required and **trying to set headers like nx-practice-id will cause the request to fail even if the token is valid for that practice.**

### Scopes ###
The full list of supported scopes:

* openid
* fhirUser
* offline_access

* launch/patient
* patient/Medication.read
* patient/AllergyIntolerance.read
* patient/CarePlan.read
* patient/CareTeam.read
* patient/Condition.read
* patient/Device.read
* patient/DiagnosticReport.read
* patient/DocumentReference.read
* patient/Encounter.read
* patient/Goal.read
* patient/Immunization.read
* patient/Location.read
* patient/MedicationRequest.read
* patient/Observation.read
* patient/Organization.read
* patient/Patient.read
* patient/Practitioner.read
* patient/Procedure.read
* patient/Provenance.read
* patient/PractitionerRole.read

* launch
* user/Medication.read
* user/AllergyIntolerance.read
* user/CarePlan.read
* user/CareTeam.read
* user/Condition.read
* user/Device.read
* user/DiagnosticReport.read
* user/DocumentReference.read
* user/Encounter.read
* user/Goal.read
* user/Immunization.read
* user/Location.read
* user/MedicationRequest.read
* user/Observation.read
* user/Organization.read
* user/Patient.read
* user/Practitioner.read
* user/Procedure.read
* user/Provenance.read
* user/PractitionerRole.read

* system/*.read

Most of the scopes map to a specific endpoint. So for example the patient/DocumentReference.read scope is required to make a GET /DocumentReference request for a patient application and user/Patient.read would be used to for a Practitioner app to make a GET /Patient request. 
